extern crate walkdir;

use std::env;
use std::fs::File;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use walkdir::{DirEntry, WalkDir};

fn main() {
    println!("cargo:rerun-if-changed=intrinsics");

    let outdir = env::var("OUT_DIR").unwrap();
    let outdir = Path::new(&outdir);
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let manifest_dir = Path::new(&manifest_dir);
    let dest = outdir.join("intrinsics.rs");

    println!("cargo:rustc-env=MIDENC_INTRINSICS={}", dest.display());

    let mut intrinsics = Vec::<(String, String, PathBuf)>::default();
    let walker = WalkDir::new("intrinsics").into_iter();
    for entry in walker.filter_entry(is_dir_or_masm_file) {
        let entry = entry.unwrap();
        let ty = entry.file_type();
        if ty.is_dir() {
            continue;
        }
        let path = entry.path().canonicalize().unwrap();
        let mut shortpath = path.strip_prefix(manifest_dir).unwrap().to_path_buf();
        shortpath.set_extension("");
        let module_parts = shortpath
            .iter()
            .map(|p| p.to_str().expect("invalid character in path"))
            .collect::<Vec<_>>();
        let module_path = module_parts.join("::");
        let module_constant = module_parts.join("_").to_ascii_uppercase();
        intrinsics.push((module_path, module_constant, path));
    }

    generate_intrinsics(&dest, &intrinsics).expect("failed to generate intrinsics");
}

fn generate_intrinsics(out: &Path, intrinsics: &[(String, String, PathBuf)]) -> io::Result<()> {
    let mut file = File::create(out)?;
    file.write_all(b"///! AUTOGENERATED by build.rs - do not modify this file\n\n")?;
    file.write_all(b"use crate::Module;\n")?;

    for (_, constant_name, path) in intrinsics.iter() {
        file.write_fmt(format_args!(
            "pub const {constant_name}: &'static str = include_str!({:?});\n",
            path
        ))?;
    }

    file.write_fmt(format_args!(
        "pub const INTRINSICS: [(&'static str, &'static str); {}] = [\n",
        intrinsics.len()
    ))?;
    for (module_name, constant_name, _) in intrinsics.iter() {
        file.write_fmt(format_args!("    (\"{module_name}\", {constant_name}),\n"))?;
    }
    file.write_all(b"];\n\n")?;

    file.write_all(b"/// This helper loads the named module from the set of intrinsics modules defined in this crate.\n")?;
    file.write_all(b"///\n")?;
    file.write_all(b"/// Expects the fully-qualified name to be given, e.g. `intrinsics::mem`\n")?;
    file.write_all(b"pub fn load<N: AsRef<str>>(name: N) -> Option<Module> {\n")?;
    file.write_all(b"    let name = name.as_ref();\n")?;
    file.write_all(b"    let (_, source) = INTRINSICS.iter().find(|(n, _)| *n == name)?;\n")?;
    file.write_all(b"    Some(Module::parse_str(source, name).expect(\"invalid module\"))\n")?;
    file.write_all(b"}\n")?;

    Ok(())
}

fn is_dir_or_masm_file(entry: &DirEntry) -> bool {
    let ty = entry.file_type();
    if ty.is_dir() {
        return true;
    }

    let path = entry.path();
    if let Some(ext) = path.extension().and_then(|ext| ext.to_str()) {
        ext == "masm"
    } else {
        false
    }
}
