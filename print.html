<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Miden Compiler Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="getting_started.html">Getting Started</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="usage/midenc.html"><strong aria-hidden="true">1.</strong> As an Executable</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> As a Library</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> As a Cargo extension</div></li><li class="chapter-item expanded affix "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="guides/rust_to_wasm.html"><strong aria-hidden="true">4.</strong> Rust To WebAssembly</a></li><li class="chapter-item expanded "><a href="guides/wasm_to_masm.html"><strong aria-hidden="true">5.</strong> WebAssembly To Miden Assembly</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> midenc</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> compile</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> exec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> run</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> cargo miden</div></li><li class="chapter-item expanded affix "><li class="part-title">Architecture</li><li class="chapter-item expanded "><a href="design/overview.html"><strong aria-hidden="true">8.</strong> Overview</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Frontends</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> HIR</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Code Generation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Testing</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix/calling_conventions.html">Calling Conventions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Miden Compiler Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xPolygonMiden/compiler/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This book attempts to provide a thorough reference for compiling to Miden Assembly
using one or more components of the Miden compiler suite. Which components you use,
and how you use them is likely to differ depending on the project, but we've tried
to provide good coverage regardless.</p>
<p>There are a set of guides which are focused on documenting the workflows for specific
use cases that we wish to ensure are well supported, or have encountered so far, but
if you feel there is anything missing, feel free to open an issue and we will try to
address the missing docs as soon as possible!</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>There are three ways you might use the Miden compiler:</p>
<ol>
<li>As an executable (via <code>midenc</code>)</li>
<li>As a library (most likely via the <code>midenc-compile</code> and <code>miden-hir</code> crates)</li>
<li>As a Cargo extension (via <code>cargo miden</code>)</li>
</ol>
<p>Each of these is described in the following chapters, we hope you find this book useful!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="as-an-executable"><a class="header" href="#as-an-executable">As an Executable</a></h1>
<p>At the present time, we do not yet have prebuilt packages of the compiler toolchain
available, so it must be built from source, but the requirements for this are minimal,
as shown below:</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>First, you'll need to have Rust installed (at time of writing, we're doing development
against Rust 1.74).</p>
<p>Then, simply install <code>midenc</code> using Cargo, like so:</p>
<pre><code># If you have cloned the git repo, and are in the project root:
cargo install --path midenc midenc

# If you have Rust installed, but have not cloned the git repo:
cargo install --git https://github.com/0xpolygonmiden/compiler --branch develop midenc
</code></pre>
<blockquote>
<p>[!NOTE]
This installation method relies on Cargo-managed binaries being in your shell <code>PATH</code>,
which is almost always the case, but if you have disabled this functionality, you'll need
to add <code>midenc</code> to your <code>PATH</code> manually.</p>
</blockquote>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Once built, you should be able to invoke the compiler now, for example:</p>
<pre><code>midenc help compile
Usage: midenc compile [OPTIONS] [-- &lt;INPUTS&gt;...]

Arguments:
  [INPUTS]...
          Path(s) to the source file(s) to compile.

          You may also use `-` as a file name to read a file from stdin.

Options:
      --output-dir &lt;DIR&gt;
          Write all compiler artifacts to DIR

  -W &lt;LEVEL&gt;
          Modify how warnings are treated by the compiler

          [default: auto]

          Possible values:
          - none:  Disable all warnings
          - auto:  Enable all warnings
          - error: Promotes warnings to errors

  -v, --verbose
          When set, produces more verbose output during compilation

  -h, --help
          Print help (see a summary with '-h')
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>We currently have two frontends to the compiler, one that accepts the compiler's IR in textual
form (as a <code>.hir</code> file), primarily used for testing; and one that accepts a WebAssembly module
in binary form (i.e. as a <code>.wasm</code> file).</p>
<p>For the vast majority of people, if not everyone, the <code>.wasm</code> form will be the one you are interested
in, so we have put together a <a href="usage/../guides/wasm_to_masm.html">helpful guide</a> that walks through how to
compile a WebAssembly module (in this case, produced by <code>rustc</code>) to Miden Assembly using <code>midenc</code>.</p>
<p>If you aren't sure how to produce a WebAssembly module, you may be interested in
<a href="usage/../guides/rust_to_wasm.html">another guide</a> that demonstrates how to emit a WebAssembly module from
a Rust crate.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="compiling-rust-to-webassembly"><a class="header" href="#compiling-rust-to-webassembly">Compiling Rust To WebAssembly</a></h1>
<p>This chapter will walk you through compiling a Rust crate to a WebAssembly (Wasm) module
in binary (i.e. <code>.wasm</code>) form. The Miden compiler has a frontend which can take such
modules and compile them on to Miden Assembly, which will be covered in the next chapter.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>First, let's set up a simple Rust project that contains an implementation of the Fibonacci
function (I know, its overdone, but we're trying to keep things as simple as possible to
make it easier to show the results at each step, so bear with me):</p>
<p>Start by creating a new library crate:</p>
<pre><code>cargo new --lib wasm-fib &amp;&amp; cd wasm-fib
</code></pre>
<p>To compile to WebAssembly, you must have the appropriate Rust toolchain installed, and we
will also need additional Cargo nightly features to build for Miden, so let's add a toolchain
file to our project root so that <code>rustup</code> and <code>cargo</code> will know what we need, and use them by
default:</p>
<pre><code>cat &lt;&lt;EOF &gt; rust-toolchain.toml
[toolchain]
channel = "nightly"
targets = ["wasm32-unknown-unknown"]
EOF
</code></pre>
<p>Next, edit the <code>Cargo.toml</code> file as follows:</p>
<pre><code class="language-toml">[package]
name = "wasm-fib"
version = "0.1.0"
edition = "2021"

[lib]
# Build this crate as a self-contained, C-style dynamic library
# This is required to emit the proper Wasm module type
crate-type = ["cdylib"]

[dependencies]
# Use a tiny allocator in place of the default one, if we want
# to make use of types in the `alloc` crate, e.g. String. We
# don't need that now, but its good information to have in hand.
#wee_alloc = "0.4"

# When we build for Wasm, we'll use the release profile
[profile.release]

# Explicitly disable panic infrastructure on Wasm, as
# there is no proper support for them anyway, and it
# ensures that panics do not pull in a bunch of standard
# library code unintentionally
panic = "abort"

# Optimize the output for size
opt-level = "z"
</code></pre>
<p>Most of these things are done to keep the generated code size as small as possible. Miden is a target
where the conventional wisdom about performance should be treated very carefully: we're almost always
going to benefit from less code, even if conventionally that code would be less efficient, simply due
to the difference in proving time accumulated due to extra instructions. That said, there are no hard
and fast rules, but these defaults are good ones to start with.</p>
<blockquote>
<p>[!TIP]
We recommended <code>wee_alloc</code> here, but any simple allocator will do, including a hand-written
bump allocator. The trade offs made by these small allocators are not generally suitable for long-
running, or allocation-heavy applications, as they "leak" memory (generally because they make little
to no attempt to recover freed allocations), however they are very useful for one-shot programs that
do minimal allocation, which is going to be the typical case for Miden programs.</p>
</blockquote>
<p>Next, edit <code>src/lib.rs</code> as shown below:</p>
<pre><code class="language-rust noplayground">// This allows us to abort if the panic handler is invoked, but
// it is gated behind a perma-unstable nightly feature
#![feature(core_intrinsics)]
// Disable the warning triggered by the use of the `core_intrinsics` feature
#![allow(internal_features)]

// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while 
// remaining no-std compatible, if we uncommented the following lines:
//
// extern crate alloc;
// use alloc::{string::String, vec::Vec};

// If we wanted to use the types mentioned above, it would also be
// a good idea to use the allocator we pulled in as a dependency
// in Cargo.toml, like so:
//#[global_allocator]
//static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// Required for no-std crates
#[panic_handler]
fn panic(info: core::panic::PanicInfo) -&gt; ! {
    core::intrinsics::abort()
}

// Marking the function no_mangle ensures that it is exported
// from the compiled binary as `fib`, otherwise it would have
// a mangled name that has no stable form.
//
// You can specify a different name from the library than the
// name in the source code using the `#[export_name = "foo"]`
// attribute, which will make the function callable as `foo`
// externally (in this example)
#[no_mangle]
pub fn fib(n: u32) -&gt; u32 {
    let mut a = 0;
    let mut b = 1;
    for _ in 0..n {
        let c = a + b;
        a = b;
        b = c;
    }
    a
}</code></pre>
<p>This exports our <code>fib</code> function from the library, making it callable from within a larger Miden program.</p>
<p>All that remains is to compile to WebAssembly:</p>
<pre><code>cargo build --release --target=wasm32-unknown-unknown
</code></pre>
<p>This places a <code>wasm_fib.wasm</code> file under the <code>target/wasm32-unknown-unknown/release/</code> directory, which
we can then examine with <a href="https://github.com/WebAssembly/wabt">wasm2wat</a> to set the code we generated:</p>
<pre><code>wasm2wat target/wasm32-unknown-unknown/release/wasm_fib.wasm
</code></pre>
<p>Which dumps the following output (may differ slightly on your machine, depending on the specific compiler version):</p>
<pre><code class="language-wat">(module
  (type (;0;) (func (param i32) (result i32)))
  (func $fib (type 0) (param i32) (result i32)
    (local i32 i32 i32)
    i32.const 0
    local.set 1
    i32.const 1
    local.set 2
    loop (result i32)  ;; label = @1
      local.get 2
      local.set 3
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        return
      end
      local.get 0
      i32.const -1
      i32.add
      local.set 0
      local.get 1
      local.get 3
      i32.add
      local.set 2
      local.get 3
      local.set 1
      br 0 (;@1;)
    end)
  (memory (;0;) 16)
  (global $__stack_pointer (mut i32) (i32.const 1048576))
  (global (;1;) i32 (i32.const 1048576))
  (global (;2;) i32 (i32.const 1048576))
  (export "memory" (memory 0))
  (export "fib" (func $fib))
  (export "__data_end" (global 1))
  (export "__heap_base" (global 2)))
</code></pre>
<p>Success!</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>In the next chapter, we will walk through how to take the WebAssembly module we just compiled, and lower
it to Miden Assembly using <code>midenc</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="compiling-webassembly-to-miden-assembly"><a class="header" href="#compiling-webassembly-to-miden-assembly">Compiling WebAssembly to Miden Assembly</a></h1>
<p>This chapter will walk you through compiling a WebAssembly (Wasm) module, in binary form
(i.e. a <code>.wasm</code> file), to an corresponding Miden Assembly (Masm) module (i.e. a <code>.masm</code> file).</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>We will be making use of the example crate we created in <a href="guides/rust_to_wasm.html">Compiling Rust to WebAssembly</a>,
which produces a small, lightweight Wasm module that is easy to examine in Wasm
text format, and demonstrates a good set of default choices for a project compiling
to Miden Assembly via WebAssembly.</p>
<p>In this chapter, we will be compiling Wasm to MASM using the <code>midenc</code> executable, so ensure that
you have followed the instructions in the <a href="guides/../usage/midenc.html">Getting Started (midenc)</a> guide
and then return here.</p>
<h2 id="compiling-to-miden-assembly"><a class="header" href="#compiling-to-miden-assembly">Compiling to Miden Assembly</a></h2>
<p>In the last chapter, we compiled a Rust crate to WebAssembly that contains an implementation
of the Fibonacci function called <code>fib</code>, that was emitted to <code>target/wasm32-unknown-unknown/release/wasm_fib.wasm</code>.
All that remains is to tell <code>midenc</code> to compile this module to WebAssembly, as shown below:</p>
<blockquote>
<p>[!NOTE]
The compiler is still under heavy development, so there are some known bugs that
may interfere with compilation depending on the flags you use - for the moment, the compiler
invocation we have to use is quite verbose, but this is a short term situation while we
address various other higher-priority tasks. Ultimately, using <code>midenc</code> directly will be
less common than other use cases (such as using <code>cargo miden</code>, or using the compiler as a
library for your own language frontend).</p>
</blockquote>
<pre><code>midenc compile -o wasm_fib.masm --emit=masm target/wasm32-unknown-unknown/release/wasm_fib.wasm
</code></pre>
<p>This will place the generated Miden Assembly code for our <code>wasm_fib</code> crate in the current directory.
If we dump the contents of this file, we'll see the following generated code:</p>
<pre><code>export.fib
  push.0
  push.1
  movup.2
  swap.1
  dup.1
  neq.0
  push.1
  while.true
    if.true
      push.4294967295
      movup.2
      swap.1
      u32wrapping_add
      dup.1
      swap.1
      swap.3
      swap.1
      u32wrapping_add
      movup.2
      swap.1
      dup.1
      neq.0
      push.1
    else
      drop
      drop
      push.0
    end
  end
end
</code></pre>
<p>If you compare this to the WebAssembly text format, you can see that this is a fairly
faithful translation, but there may be areas where we generate sub-optimal Miden Assembly.</p>
<p>At the moment the compiler does only minimal optimization, late in the pipeline during codegen,
and only in regards to operand stack management. In other words, if you see an instruction
sequence you think is bad, certainly bring it to our attention, but we can't guarantee that
the code we generate will match what you would write by hand.</p>
<h2 id="testing-with-the-miden-vm"><a class="header" href="#testing-with-the-miden-vm">Testing with the Miden VM</a></h2>
<blockquote>
<p>[!NOTE]
This example is more complicated than it needs to be at the moment, bear with us!</p>
</blockquote>
<p>Assuming you have followed the instruction for installing the Miden VM locally,
we can test this program out as follows:</p>
<p>First, we need to define a program to link our <code>wasm_fib.masm</code> module into, since
it is not a program, but a library module:</p>
<pre><code>cat &lt;&lt;EOF &gt; main.masm
use.wasm_fib::wasm_fib

begin
    exec.wasm_fib::fib
end
</code></pre>
<p>We will also need a <code>.inputs</code> file to pass arguments to the program:</p>
<pre><code>cat &lt;&lt;EOF &gt; wasm_fib.inputs
{
    "operand_stack": ["10"],
    "advice_stack": ["0"],
}
</code></pre>
<p>Next, we need to build a MASL library (normally <code>midenc</code> would do this, but there is a bug
blocking it at the moment, this example will be updated accordingly soon):</p>
<pre><code>mkdir -p wasm_fib &amp;&amp; mv wasm_fib.masm wasm_fib/
miden bundle -n wasm_fib wasm_fib
</code></pre>
<p>With these in place, we can put it all together and run it:</p>
<pre><code>miden run -a main.masm -n 1 -i wasm_fib.inputs -l wasm_fib/wasm_fib.masl
============================================================
Run program
============================================================
Reading library file `wasm_fib/wasm_fib.masl`
Reading program file `main.masm`
Parsing program... done (0 ms)
Compiling program... done (2 ms)
Reading input file `wasm_fib.inputs`
Executing program with hash 3d965e7c6cfbcfe9d9db67262cbbc31517931a0169257f385d447d497cf55778... done (1 ms)
Output: [55]
VM cycles: 263 extended to 512 steps (48% padding).
├── Stack rows: 263
├── Range checker rows: 67
└── Chiplets rows: 201
    ├── Hash chiplet rows: 200
    ├── Bitwise chiplet rows: 0
    ├── Memory chiplet rows: 0
    └── Kernel ROM rows: 0
</code></pre>
<p>Success! We got the expected result of <code>55</code>.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>This guide is not comprehensive, as we have not yet examined in detail the differences between
compiling libraries vs programs, linking together multiple libraries, emitting a <code>.masl</code> library,
or discussed some of the compiler options. We will be updating this documentation with those
details and more in the coming days, so bear with us while we flesh out our guides!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="compiler-architecture"><a class="header" href="#compiler-architecture">Compiler Architecture</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="calling-conventions"><a class="header" href="#calling-conventions">Calling Conventions</a></h1>
<p>This document describes the various calling conventions recognized/handled by the compiler,
including a specification for the interaction with the IR type system.</p>
<p>There are four calling conventions represented in the compiler:</p>
<ul>
<li><code>C</code> aka <code>SystemV</code>, which corresponds to the C ABI commonly used for C foreign-function interfaces (FFI).
We specifically use the System V ABI because it is well understood, documented, and straightforward.</li>
<li><code>Fast</code>, this convention allows the compiler to follow either the <code>C</code> calling convention, or modify it
as it sees fit on a function-by-function basis. This convention provides no guarantees about how a
callee will expect arguments to be passed, so should not be used for functions which are expected to
have a stable, predictable interface. This is a good choice for local functions, or functions which are
only used within an executable/library and are not part of the public interface.</li>
<li><code>Kernel</code>, this is a special calling convention that is used when defining kernel modules in the IR.
Functions which are part of the kernel's public API are required to use this convention, and it is not
possible to call a function via <code>syscall</code> if the callee is not defined with this convention. Because of
the semantics of <code>syscall</code>, this convention is highly restrictive. In particular, it is not permitted to
pass pointer arguments, or aggregates containing pointers, as <code>syscall</code> involves a context switch, and
thus memory in the the caller is not accessible to the callee, and vice versa.</li>
<li><code>Contract</code>, this is a special calling convention that is used when defining smart contract functions, i.e.
functions that can be <code>call</code>'d. The compiler will not permit you to <code>call</code> a function if the callee is not
defined with this convention, and functions with this convention cannot be called via <code>exec</code>. Like <code>syscall</code>,
the <code>call</code> instruction involves a context switch, however, unlike the <code>Kernel</code> convention, the <code>Contract</code>
convention is allowed to have types in its signature that are/contain pointers, with certain caveats around
those pointers.</li>
</ul>
<p>All four conventions above are based on the System V C ABI, tailored to the Miden VM. The only exception is
<code>Fast</code>, which may modify the ABI arbitrarily as it sees fit, and makes no guarantees about what modifications,
if any, it will make.</p>
<h1 id="data-representation"><a class="header" href="#data-representation">Data Representation</a></h1>
<p>The following is a description of how the IR type system is represented in the <code>C</code> calling convention. Later,
a description of how the other conventions extend/restrict/modify this representation will be provided.</p>
<h2 id="scalars"><a class="header" href="#scalars">Scalars</a></h2>
<div class="table-wrapper"><table><thead><tr><th>General type</th><th>C Type</th><th>IR Type</th><th><code>sizeof</code></th><th>Alignment (bytes)</th><th>Miden Type</th></tr></thead><tbody>
<tr><td>Integer</td><td><code>_Bool</code>/<code>bool</code></td><td><code>I1</code></td><td>1</td><td>1</td><td>u32</td></tr>
<tr><td>Integer</td><td><code>char</code>, <code>signed char</code></td><td><code>I8</code></td><td>1</td><td>1</td><td>i32<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td>Integer</td><td><code>unsigned char</code></td><td><code>U8</code></td><td>1</td><td>1</td><td>u32</td></tr>
<tr><td>Integer</td><td><code>short</code> / <code>signed short</code></td><td><code>I16</code></td><td>2</td><td>2</td><td>i32<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td>Integer</td><td><code>unsigned short</code></td><td><code>U16</code></td><td>2</td><td>2</td><td>u32</td></tr>
<tr><td>Integer</td><td><code>int</code> / <code>signed int</code> / <code>enum</code></td><td><code>I32</code></td><td>4</td><td>4</td><td>i32[^1]<sup class="footnote-reference"><a href="#8">2</a></sup></td></tr>
<tr><td>Integer</td><td><code>unsigned int</code></td><td><code>U32</code></td><td>4</td><td>4</td><td>u32</td></tr>
<tr><td>Integer</td><td><code>long</code> / <code>signed long</code></td><td><code>I32</code></td><td>4</td><td>4</td><td>i32<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td>Integer</td><td><code>unsigned long</code> / <code>size_t</code></td><td><code>U32</code></td><td>4</td><td>4</td><td>u32</td></tr>
<tr><td>Integer</td><td><code>long long</code> / <code>signed long long</code></td><td><code>I64</code></td><td>8</td><td>8</td><td>i64<sup class="footnote-reference"><a href="#2">3</a></sup></td></tr>
<tr><td>Integer</td><td><code>unsigned long long</code></td><td><code>U64</code></td><td>8</td><td>8</td><td>u64<sup class="footnote-reference"><a href="#3">4</a></sup></td></tr>
<tr><td>Pointer</td><td><em><code>any-type *</code></em> / <em><code>any-type (*)()</code></em></td><td><code>Ptr(_)</code></td><td>4</td><td>4</td><td>u32[^6]<sup class="footnote-reference"><a href="#7">5</a></sup></td></tr>
<tr><td>Floating point</td><td><code>float</code></td><td><code>F32</code></td><td>4</td><td>4</td><td>u32<sup class="footnote-reference"><a href="#4">6</a></sup></td></tr>
<tr><td>Floating point</td><td><code>double</code></td><td><code>F64</code></td><td>8</td><td>8</td><td>u64<sup class="footnote-reference"><a href="#4">6</a></sup></td></tr>
<tr><td>Floating point</td><td><code>long double</code></td><td>16</td><td>16</td><td>(none)<sup class="footnote-reference"><a href="#5">7</a></sup></td><td></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>i32 is not a native Miden type, but is implemented using compiler intrinsics on top of the native u32 type</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>i64 is not a native Miden type, but is implemented using compiler intrinsics on top of the stdlib u64 type</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">4</sup>
<p>u64 is not a native Miden type, but is implemented in software using two 32-bit limbs (i.e. a pair of field elements)</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">6</sup>
<p>floating-point types are not currently supported, but will be implemented using compiler intrinsics</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">7</sup>
<p><code>long double</code> values correspond to 128-bit IEEE-754 quad-precision binary128 values. These are not currently
supported, and we have no plans to support them in the near term. Should we ever provide such support, we will do
so using compiler intrinsics.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">8</sup>
<p>A null pointer (for all types) always has the value zero.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">5</sup>
<p>Miden's linear memory is word-addressable, not byte-addressable. The <code>Ptr</code> type has an <code>AddressSpace</code> parameter,
that by default is set to the byte-addressable address space. The compiler translates values of <code>Ptr</code> type that are in
this address space, into the Miden-native, word-addressable address space during codegen of load/store operations. See
the section on the memory model below for more details.</p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">2</sup>
<p>An <code>enum</code> is <code>i32</code> if all members of the enumeration can be represented by an <code>int</code>/<code>unsigned int</code>, otherwise it
uses i64.</p>
</div>
<blockquote>
<p>[!NOTE]
The compiler does not support scalars larger than one word (128 bits) at this time. As a result, anything that is
larger than that must be allocated in linear memory, or in an automatic allocation (function-local memory), and passed
around by reference.</p>
</blockquote>
<p>The native scalar type for the Miden VM is a "field element", specifically a 64-bit value representing an integer
in the "Goldilocks" field, i.e. <code>0..(2^64-2^32+1)</code>. A number of instructions in the VM operate on field elements directly.
However, the native integral/pointer type, i.e. a "machine word", is actually <code>u32</code>. This is because a field element
can fully represent 32-bit integers, but not the full 64-bit integer range. Values of <code>u32</code> type are valid field element
values, and can be used anywhere that a field element is expected (barring other constraints).</p>
<p>Miden also has the notion of a "word", not to be confused with a "machine word" (by which we mean the native integral
type used to represent pointers), which corresponds to a set of 4 field elements. Words are commonly used in Miden,
particularly to represent hashes, and a number of VM instructions operate on word-sized operands. As an aside, 128-bit
integer values are represented using a word, or two 64-bit limbs (each limb consisting of two 32-bit limbs).</p>
<p>All integral types mentioned above, barring field elements, use two's complement encoding. Unsigned integral types
make use of the sign bit to change the value range (i.e. 0..2^32-1, rather than -2^31..2^31-1), but the encoding follows
two's complement rules.</p>
<p>The Miden VM only has native support for field elements, words, and <code>u32</code>; all other types are implemented in software
using intrinsics.</p>
<h2 id="aggregates-and-unions"><a class="header" href="#aggregates-and-unions">Aggregates and Unions</a></h2>
<p>Structures and unions assume the alignment of their most strictly aligned component. Each member is assigned to the
lowest available offset with the appropriate alignment. The size of any object is always a multiple of the object's alignment.
An array uses the same alignment as its elements. Structure and union objects can require padding to meet size and alignment
constraints. The contents of any padding is undefined.</p>
<h2 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h2>
<p>Interacting with memory in Miden is quite similar to WebAssembly in some ways:</p>
<ul>
<li>The address space is linear, with addresses starting at zero, and ranging up to 2^32-1</li>
<li>There is no memory protection per se, you either have full read/write access, or no access to a specific memory context</li>
<li>How memory is used is completely up the program being executed</li>
</ul>
<p>This is where it begins to differ though, and takes on qualities unique to Miden (in part, or whole):</p>
<ul>
<li>Certain regions of the address space are "reserved" for special uses, improper use of those regions may result in
undefined behavior.</li>
<li>Miden has different types of function call instructions: <code>call</code> vs <code>syscall</code> vs <code>exec</code>. The first two
perform a context switch when transferring control to the callee, and the callee has no access to the
caller's memory (and the caller has no access to the callee's memory). As a result, references to memory
cannot be passed from caller to callee in arguments, nor can they be returned from the callee to the caller.</li>
<li>Most significant of all though, is that Miden does not have byte-addressable memory, it is instead word-addressable,
i.e. every address refers to a full word.</li>
<li>It is not possible to load a specific field element from a word in memory, unless it happens to be the first element
of the word. Instead, one must load the full word, and drop the elements you don't need.</li>
</ul>
<p>This presents some complications, particularly:</p>
<ul>
<li>Most languages assume a byte-oriented memory model, which is not trivially mapped to a word-oriented model</li>
<li>Simple things, such as taking the address of a field in a struct, and then dereferencing it, cannot be directly
represented in Miden using native pointer arithmetic and <code>load</code> instruction. Operations like this must be translated
into instruction sequences that load whole words from memory, extract the data needed, and discard the unused bits.
This makes the choice of where in memory to store something much more important than byte-addressable memory, as
loads of values which are not aligned to element or word boundaries can be quite inefficient in some cases.</li>
</ul>
<p>The compiler solves this by providing a byte-addressable IR, and internally translating operations in the IR to the equivalent
sequence of Miden instructions needed to emulate that operation. This translation is done during code generation, and uses
the following semantics to determine how a particular operation gets lowered:</p>
<ul>
<li>A byte-addressable pointer can be emulated in Miden's word-addressable environment using three pieces of information:
<ul>
<li>The address of the word containing the first byte of the value, this is a "native" Miden address value</li>
<li>The index of the field element within that word containing the first byte of the value</li>
<li>The offset (in bytes) from the start of the 4 byte chunk represented by the selected element, corresponding
to the first byte of the value. Since the chunk is represented as a u32 value, the offset is relative to the
most-significant bit (i.e. the byte with the lowest address is found in bits 55-63, since Miden integers are little-endian)</li>
</ul>
</li>
<li>This relies on us treating Miden's linear memory as an array of 16-byte chunks of raw memory (each word is 4 field elements,
each element represents a 4-byte chunk). In short, much like translating a virtual memory address to a physical one, we must
translate byte-addressable "virtual" pointers to "real" Miden pointers with enough metadata to be able to extract the data we're
trying to load (or encode the data we're trying to store).</li>
</ul>
<p>Because we're essentially emulating byte-addressable memory on word-addressable memory, loads/stores can range from simple and
straightforward, to expensive and complicated, depending on the size and alignment of the value type. The process goes as follows:</p>
<ul>
<li>If the value type is word-aligned, it can be loaded/stored in as little as a single instruction depending on the size of the type</li>
<li>Likewise if the value type is element-aligned, and the address is word-aligned</li>
<li>Element-aligned values require some extra instructions to load a full word and drop the unused elements (or in the case of stores,
loading the full word and replacing the element being stored)</li>
<li>Loads/stores of types with sub-element alignment depend on the alignment of the pointer itself. Element or word-aligned addresses
are still quite efficient to load/store from, but if the first byte of the value occurs in the middle of an element, then the bytes
of that value must be shifted into place (or unused bytes masked out). If the value crosses an element boundary, then the bytes in
both elements must be isolated and shifted into position such that they can be bitwise-OR'd together to obtain the aligned value on
the operand stack. If a value crosses a word boundary, then elements from both words must be loaded, irrelevant ones discarded, the
relevant bytes isolated and shifted into position so that the resulting operand on the stack is aligned and laid out correctly.</li>
<li>Stores are further complicated by the need to preserve memory that is not being explicitly written to, so values that do not overwrite
a full word or element, require combining bytes from the operand being stored and what currently resides in memory.</li>
</ul>
<p>The worst case scenario for an unaligned load or store involves a word-sized type starting somewhere in the last element of the first
word. This will require loading elements from three consecutive words, plus a lot of shuffling bits around to get the final, aligned
word-sized value on the operand stack. Luckily, such operations should be quite rare, as by default all word-sized scalar types are
word-aligned or element-aligned, so an unaligned load or store would require either a packed struct, or a type such as an array of
bytes starting at some arbitrary address. In practice, most loads/stores are likely to be element-aligned, so most overhead from
emulation will come from values which cross an element or word boundary.</p>
<h1 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h1>
<p>This section describes the conventions followed when executing a function call via <code>exec</code>, including how arguments are passed on the
operand stack, stack frames, etc. Later, we'll cover the differences when executing calls via <code>call</code> or <code>syscall</code>.</p>
<h2 id="locals-and-the-stack-frame"><a class="header" href="#locals-and-the-stack-frame">Locals and the stack frame</a></h2>
<p>Miden does not have registers in the style of hardware architectures. Instead it has an operand stack, on which an arbitrary number of
operands may be stored, and local variables. In both cases - an operand on the operand stack, or a single local variable - the value
type is nominally a field element, but it is easier to reason about them as untyped element-sized values. The operand stack is used
for function arguments, return values, temporary variables, and scratch space. Local variables are not always used, but are typically
used to hold multiply-used values which you don't want to keep on the operand stack, function-scoped automatic allocations (i.e. <code>alloca</code>),
and other such uses.</p>
<p>Miden does not have a stack frame per se. When you call a procedure in Miden Assembly, any local variables declared by that procedure
are allocated space in a reserved region of linear memory in a single consecutive chunk. However, there is no stack or frame pointer,
and because Miden is a Harvard architecture machine, there are no return addresses. Instead, languages (such as C) which have the concept
of a stack frame with implications for the semantics of say, taking the address of a local variable, will need to emit code in function
prologues and epilogues to maintain a shadow stack in Miden's linear memory. If all you need is local variables, you can get away with
leaning on Miden's notion of local variables without implenting a shadow stack.</p>
<p>Because there are no registers, the notion of callee-saved or caller-saved registers does not have a direct equivalent in Miden. However,
in its place, a somewhat equivalent set of rules defines the contract betweeen caller and callee in terms of the state of the operand stack,
those are described below in the section covering the operand stack.</p>
<h3 id="the-shadow-stack"><a class="header" href="#the-shadow-stack">The shadow stack</a></h3>
<p>Miden is a <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard</a> architecture; as such, code and data are not in the same memory
space. More precisely, in Miden, code is only addressable via the hash of the MAST root of that code, which must correspond to code that
has been loaded into the VM. The hash of the MAST root of a function can be used to call that function both directly and indirectly, but
that is the only action you can take with it. Code can not be generated and called on the fly, and it is not stored anywhere that is
accessible to code that is currently executing.</p>
<p>One consequence of this is that there are no return addresses or instruction pointers visible to executing code. The runtime call stack is
managed by the VM itself, and is not exposed to executing code in any way. This means that address-taken local C variables need to be on a
separate stack in linear memory (which we refer to as a "shadow stack"). Not all functions necessarily require a frame in the shadow stack,
as it cannot be used to perform unwinding, so only functions which have locals require a frame.</p>
<p>The Miden VM actually provides some built-in support for stack frames when using Miden Assembly. Procedures which are declared with some
number of locals, will be automatically allocated sufficient space for those locals in a reserved region of linear memory when called. If
you use the <code>locaddr</code> instruction to get the actual address of a local, that address can be passed as an argument to callees (within the
constraints of the callee's calling convention).</p>
<p>Languages with more elaborate requirements with regard to the stack will need to implement their own shadow stack, and emit code in function
prologues/epilogues to manage it.</p>
<h3 id="the-operand-stack"><a class="header" href="#the-operand-stack">The operand stack</a></h3>
<p>The Miden virtual machine is a stack machine, not a register machine. Rather than having a fixed set of registers that are used to
store and manipulate scalar values, the Miden VM has the operand stack, which can hold an arbitrary number of operands (where each
operand is a single field element), of which the first 16 can be directly manipulated using special stack instructions. The operand
stack is, as the name implies, a last-in/first-out data structure.</p>
<p>The following are basic rules all conventions are expected to follow with regard to the operand stack:</p>
<ol>
<li>The state of the operand stack from the point of view of the caller should be preserved, with two exceptions:</li>
</ol>
<ul>
<li>The callee is expected to consume all of its arguments, and the caller will expect those operands to be gone when control is returned to it</li>
<li>If the callee signature declares a return value, the caller expects to see that on top of the stack when control is returned to it</li>
</ul>
<ol start="2">
<li>No more than 16 elements of the operand stack may be used for passing arguments. If more than that is required to represent all of the arguments,
then one of the following must happen:</li>
</ol>
<ul>
<li>Spill to stack frame: in this scenario, up to 15 elements of the operand stack are used for arguments, and the remaining element is used to hold
a pointer to a local variable in the caller's stack frame. That local variable is a struct whose fields are the spilled arguments, appearing in
the same order as they would be passed. The callee must use the pointer it is given to compute the effective address for each spilled argument
that it wishes to access.</li>
<li>Spill to heap: this is basically identical to the approach above, except the memory is allocated from the global heap, rather than using memory
associated with the caller's stack frame.</li>
<li>Spill to the advice provider: in this scenario, 12 elements of the stack are used for arguments, and the remaining 4 are used to hold a hash
which refers to the remaining arguments on the advice provider stack. The callee must arrange to fetch the spilled arguments from the advice
provider using that hash.</li>
</ul>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function signatures</a></h3>
<p>Miden Abstract Syntax Trees (MASTs) do not have any notion of functions, and as such are not aware of parameters, return values, etc. For
this document, that's not a useful level of abstraction to examine. Even a step higher, Miden Assembly (MASM) has functions (procedures
in MASM parlance), but no function signature, i.e. given a MASM procedure, there is no way to know how many arguments it expects, how
many values it returns, let alone the types of arguments/return values. Instead, we're going to specify calling conventions in terms of
Miden IR, which has a fairly expressive type system more or less equivalent to that of LLVM, and how that translates to Miden primitives.</p>
<p>Functions in Miden IR always have a signature, which specify the following:</p>
<ul>
<li>The calling convention required to call the function</li>
<li>The number and types of the function arguments</li>
<li>The type of value, if any, returned by by the function, and whether it is returned by value or reference</li>
</ul>
<p>The following table relates IR types to how they are expected to be passed from the caller to the callee, and vice versa:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Parameter</th><th>Result</th></tr></thead><tbody>
<tr><td>scalar</td><td>direct</td><td>direct</td></tr>
<tr><td>empty struct or union<sup class="footnote-reference"><a href="#1">1</a></sup></td><td>ignored</td><td>ignored</td></tr>
<tr><td>scalar struct or union<sup class="footnote-reference"><a href="#2">3</a></sup></td><td>direct</td><td>direct</td></tr>
<tr><td>other struct or union</td><td>indirect</td><td>indirect</td></tr>
<tr><td>array</td><td>indirect</td><td>N/A</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Zero-sized types have no representation in memory, so they are ignored/skipped</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>Any struct or union that recursively (including through nested structs,
unions, and arrays) contains just a single scalar value and is not specified to
have greater than natural alignment.</p>
</div>
<p>The compiler will automatically generate code that follows these rules, but if emitting MASM from your own backend, it is necessary to do so manually.
For example, a function whose signature specifies that it returns a non-scalar struct by value, must actually be written such that it expects to receive
a pointer to memory allocated by the caller sufficient to hold the return value, as the first parameter of the function (i.e. the parameter is prepended
to the parameter list). When returning, the function must write the return value to that pointer, rather than returning it on the operand stack. In this
example, the return value is returned indirectly (by reference).</p>
<p>A universal rule is that the arguments are passed in reverse order, i.e. the first argument in the parameter list of a function will be on top of the
operand stack. This is different than many Miden instructions which seemingly use the opposite convention, e.g. <code>add</code>, which expects the right-hand
operand on top of the stack, so <code>a + b</code> is represented like <code>push a, push b, add</code>. If we were to implement <code>add</code> as a function, it would instead be
<code>push b, push a, exec.add</code>. The rationale behind this is that, in general, the more frequently used arguments appear earlier in the parameter list,
and thus we want those closer to the top of the operand stack to reduce the amount of stack manipulation we need to do.</p>
<p>Arguments/return values are laid out on the operand stack just like they would be as if you had just loaded it from memory, so all arguments are aligned,
but may span multiple operands on the operand stack as necessary based on the size of the type (i.e. a struct type that contains a <code>u32</code> and a <code>i1</code>
field would require two operands to represent). If the maximum number of operands allowed for the call is reached, any remaining arguments must be
spilled to the caller's stack frame, or to the advice provider. The former is used in the case of <code>exec</code>/<code>dynexec</code>, while the latter is used for <code>call</code>
and <code>syscall</code>, as caller memory is not accessible to the callee with those instructions.</p>
<p>While ostensibly 16 elements is the maximum number of operands on the operand stack that can represent function arguments, due to the way <code>dynexec</code>/<code>dyncall</code>
work, it is actually limited to 12 elements, because at least 4 must be free to hold the hash of the function being indirectly called.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
